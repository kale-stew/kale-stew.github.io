<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Understanding the TypeScript Compiler</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/github.min.css" data-svelte="svelte-b0idxc"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxygen" data-svelte="svelte-b0idxc"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Mono" data-svelte="svelte-b0idxc">

		

		<link rel="modulepreload" href="/internal/start-2f6e92c7.js">
		<link rel="modulepreload" href="/internal/chunks/vendor-50d67180.js">
		<link rel="modulepreload" href="/internal/chunks/paths-28a87002.js">
		<link rel="modulepreload" href="/internal/pages/__layout.svelte-766813b2.js">
		<link rel="modulepreload" href="/internal/pages/[slug].svelte-516ac371.js">
		<link rel="stylesheet" href="/internal/assets/start-61d1577b.css">
		<link rel="stylesheet" href="/internal/assets/pages/__layout.svelte-37ba07d1.css">
		<link rel="stylesheet" href="/internal/assets/pages/[slug].svelte-ecef8022.css">

		<script type="module">
			import { start } from "/internal/start-2f6e92c7.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				host: location.host,
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/internal/pages/__layout.svelte-766813b2.js"),
						import("/internal/pages/[slug].svelte-516ac371.js")
					],
					page: {
						host: location.host, // TODO this is redundant
						path: "/understanding-the-ts-compiler",
						query: new URLSearchParams(""),
						params: {"slug":"understanding-the-ts-compiler"}
					}
				}
			});
		</script>
  </head>
  <body>
    <div id="svelte">




<div><nav class="svelte-1pzvsga"><a href="/" class="svelte-1pzvsga"><h3 class="home svelte-1pzvsga">home</h3></a>
    <a href="/blog" class="svelte-1pzvsga"><h3 class="blog svelte-1pzvsga">blog</h3></a>
    <a href="/about" class="svelte-1pzvsga"><h3 class="about svelte-1pzvsga">about</h3></a></nav>
</div>
<div class="g-content-wrapper svelte-1c6jjpl">

<div class="post svelte-14ss73z"><h1 class="title svelte-14ss73z">Understanding the TypeScript Compiler</h1>
  <p class="date svelte-14ss73z">MAY 19, 2020</p>
  <!-- HTML_TAG_START --><p>I am trying to thoroughly test a library that has TypeScript support, but too many use cases to accurately track without contacting hundreds of thousands of consumers of said library to ensure we thoroughly understand it's many, many use cases.</p>
<p>The library consists of a single function, and the types themselves are very simple:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEqual</span>&#x3C;<span class="hljs-title">A</span> = <span class="hljs-title">any</span>, <span class="hljs-title">B</span> = <span class="hljs-title">any</span>>(<span class="hljs-params">a: A, b: B</span>): <span class="hljs-title">boolean</span>
<span class="hljs-title">declare</span> <span class="hljs-title">namespace</span> <span class="hljs-title">isEqual</span> </span>{}
<span class="hljs-keyword">export</span> = isEqual
</code></pre>
<p>As a single function that compares two elements and returns a boolean, you can imagine the use cases are fairly wide-ranging. Folks want to compare deeply-nested objects and get a proper result, and I can relate! This package is a fork of a package that does the same comparison, but this package adds handlers specific to React (and now Preact/compat!), allowing it to dive deeply into React components and pull out the correct value for comparison.</p>
<h2>TypeScript Usage Testing Goal</h2>
<p>We want to target a specific directory to test our TypeScript in real-time, but without affecting the entire project ecosystem.</p>
<p>We want this script to successfully run both locally and in CI, in 3 different Node environments.</p>
<p>We want this test to identify any regressions introduced to the src or types themselves.</p>
<h2><code>tsc</code></h2>
<p>So, we have a set of tests living inside of a <code>test/typescript</code> dir. We are reaching these tests with a script that is run from the root's <code>package.json</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// The script we are focused on testing right now</span>
<span class="hljs-string">"test-ts-usage"</span>: <span class="hljs-string">"tsc --jsx react --target ES6 --noImplicitAny --esModuleInterop typescript/index.tsx"</span>,

<span class="hljs-comment">// This script existed before this test addition</span>
<span class="hljs-comment">// It runs the existing index and makes sure there are no immediate errs</span>
<span class="hljs-string">"test-ts-defs"</span>: <span class="hljs-string">"tsc --target ES5 --noImplicitAny index.d.ts"</span>,
</code></pre>
<h3>What is it doing right now?</h3>
<p>Currently, when we run our <code>test-ts-usage</code> script, it is compiling <em>every</em> package we depend on, including testing libraries that aren't being invoked by our test file itself. This is because of the compiler. I am suspicious that it's viewing the project as a single entity, hence the all-encompassing compiling, so let's dive into the compiler to see what options we'll need to flag to get it to treat this single <code>tsx</code> file as an independently nested project.</p>
<p>To see the test <code>tsx</code> file I am running this usage script against, check out this gist of typescript tests. </p>
<h3>How can we fix this?</h3>
<p>We can use a combination of <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">compiler options</a> and a <a href="https://www.typescriptlang.org/docs/handbook/project-references.html">project reference</a> to achieve our testing goal here.</p>
<p>Using the project reference, we can direct <code>tsc</code> to view our mini suite as a project of its own, without installing peer dependencies from the root repository. But what is required to substantiate an entire project? How much boilerplate needs to be initialized?</p>
<p>According to <a href="https://www.typescriptlang.org/docs/handbook/project-references.html#what-is-a-project-reference">this blurb</a> in the docs defining a project reference, we only need to</p>
<ol>
<li>
<p>Add a top-level key of <code>references</code> to our root <code>tsconfig.json</code>, a small array of objects of projects to refer to.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* react-fast-compare/tsconfig.json */</span>
{
 <span class="hljs-string">"compilerOptions"</span>: {
   <span class="hljs-string">"noImplicitAny"</span>: <span class="hljs-literal">true</span>
 },
 <span class="hljs-string">"references"</span>: [{ <span class="hljs-string">"path"</span>: <span class="hljs-string">"test/typescript"</span> }]
}
</code></pre>
</li>
<li>
<p>Add a <code>tsconfig,json</code> to the test directory we've pointed to as a separate project. All referenced projects need to have the <a href="https://www.typescriptlang.org/docs/handbook/project-references.html#composite"><code>composite</code> flag</a> enabled "to ensure TypeScript can quickly determine where to find the outputs of the referenced project". </p>
</li>
</ol>
<p>Now we can isolate our react-specific flags to the following:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* react-fast-compare/test/typescript/tsconfig.json */</span>
{
 <span class="hljs-string">"compilerOptions"</span>: {
   <span class="hljs-string">"composite"</span>: <span class="hljs-literal">true</span>,
   <span class="hljs-string">"esModuleInterop"</span>: <span class="hljs-literal">true</span>,
   <span class="hljs-string">"jsx"</span>: <span class="hljs-string">"react"</span>,
   <span class="hljs-string">"target"</span>: <span class="hljs-string">"ES6"</span>
 }
}
</code></pre>
<h3>More about <code>tsconfig</code>s</h3>
<p>Looking at <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">the docs</a>, we know that the presence of a <code>tsconfig.json</code> in a directory indicates that the directory is the <em>root</em> of a TypeScript project.</p>
<p>The file is used to specify</p>
<ul>
<li>root files and their names</li>
<li>compiler options required to compile the project
<ul>
<li><code>tsc</code> is invoked with no input files, the compiler looks for a <code>tsconfig</code></li>
<li><code>tsx</code> is invoked with no input files but a <code>--project</code> is passed, specifying the path of a directory containing a tsconfig <em>or</em> valid json file with configurations (so it <strong>can</strong> be renamed in a sub-directory!)</li>
</ul>
</li>
</ul>
<blockquote>
<p>When input files are specified on the command line, tsconfig.json files are ignored.</p>
</blockquote>
<p>So, this means, we can designate a project, point to a valid .json within that directory, and compile it independently. We now know we have the option to <em>extend</em> a root <code>tsconfig</code>, or override it completely. I think it'll be more worthwhile to extend our existing config because the project is tiny enough that our source-of-truth approach should suffice; we don't need a wide variety of <code>tsconfig</code>s to test against or anything.</p><!-- HTML_TAG_END -->
</div></div>
<div class="footer svelte-1ts4n1w"><div class="links svelte-1ts4n1w"><a href="mailto:kylie@kyliestewart.tech" class="svelte-1ts4n1w"><svg focusable="false" width="1rem" height="1rem" viewBox="0 0 24 24"><!-- HTML_TAG_START --><path d="M24 0l-6 22-8.129-7.239 7.802-8.234-10.458 7.227-7.215-1.754 24-12zm-15 16.668v7.332l3.258-4.431-3.258-2.901z"/><!-- HTML_TAG_END --></svg></a>
    <a href="https://linkedin.com/in/kylieastewart" class="svelte-1ts4n1w"><svg title="Click here to connect with Kylie on LinkedIn." focusable="false" width="1rem" height="1rem" viewBox="0 0 24 24"><!-- HTML_TAG_START --><path d="M4.98 3.5c0 1.381-1.11 2.5-2.48 2.5s-2.48-1.119-2.48-2.5c0-1.38 1.11-2.5 2.48-2.5s2.48 1.12 2.48 2.5zm.02 4.5h-5v16h5v-16zm7.982 0h-4.968v16h4.969v-8.399c0-4.67 6.029-5.052 6.029 0v8.399h4.988v-10.131c0-7.88-8.922-7.593-11.018-3.714v-2.155z"/><!-- HTML_TAG_END --></svg></a>
    <a href="https://www.twitter.com/kyliestew" class="svelte-1ts4n1w"><svg title="Click here to follow Kylie on Twitter." focusable="false" width="1rem" height="1rem" viewBox="0 0 24 24"><!-- HTML_TAG_START --><path d="M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z"/><!-- HTML_TAG_END --></svg></a>
    <a href="https://instagram.com/kalestews" class="svelte-1ts4n1w"><svg title="Click here to follow Kylie on Instagram." focusable="false" width="1rem" height="1rem" viewBox="0 0 24 24"><!-- HTML_TAG_START --><path d="M11.984 16.815c2.596 0 4.706-2.111 4.706-4.707 0-1.409-.623-2.674-1.606-3.538-.346-.303-.735-.556-1.158-.748-.593-.27-1.249-.421-1.941-.421s-1.349.151-1.941.421c-.424.194-.814.447-1.158.749-.985.864-1.608 2.129-1.608 3.538 0 2.595 2.112 4.706 4.706 4.706zm.016-8.184c1.921 0 3.479 1.557 3.479 3.478 0 1.921-1.558 3.479-3.479 3.479s-3.479-1.557-3.479-3.479c0-1.921 1.558-3.478 3.479-3.478zm5.223.369h6.777v10.278c0 2.608-2.114 4.722-4.722 4.722h-14.493c-2.608 0-4.785-2.114-4.785-4.722v-10.278h6.747c-.544.913-.872 1.969-.872 3.109 0 3.374 2.735 6.109 6.109 6.109s6.109-2.735 6.109-6.109c.001-1.14-.327-2.196-.87-3.109zm2.055-9h-12.278v5h-1v-5h-1v5h-1v-4.923c-.346.057-.682.143-1 .27v4.653h-1v-4.102c-1.202.857-2 2.246-2 3.824v3.278h7.473c1.167-1.282 2.798-2 4.511-2 1.722 0 3.351.725 4.511 2h7.505v-3.278c0-2.608-2.114-4.722-4.722-4.722zm2.722 5.265c0 .406-.333.735-.745.735h-2.511c-.411 0-.744-.329-.744-.735v-2.53c0-.406.333-.735.744-.735h2.511c.412 0 .745.329.745.735v2.53z"/><!-- HTML_TAG_END --></svg></a></div>
</div>



	<script type="application/json" data-type="svelte-data" data-url="/understanding-the-ts-compiler.json">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"{\"metadata\":{\"title\":\"Understanding the TypeScript Compiler\",\"date\":\"May 19, 2020\",\"excerpt\":\"Working to better understand the language and how it differs from my first love, JavaScript.\"},\"content\":\"\u003Cp\u003EI am trying to thoroughly test a library that has TypeScript support, but too many use cases to accurately track without contacting hundreds of thousands of consumers of said library to ensure we thoroughly understand it's many, many use cases.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe library consists of a single function, and the types themselves are very simple:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-ts\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Edeclare\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-function\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title\\\"\u003EisEqual\u003C\u002Fspan\u003E&#x3C;\u003Cspan class=\\\"hljs-title\\\"\u003EA\u003C\u002Fspan\u003E = \u003Cspan class=\\\"hljs-title\\\"\u003Eany\u003C\u002Fspan\u003E, \u003Cspan class=\\\"hljs-title\\\"\u003EB\u003C\u002Fspan\u003E = \u003Cspan class=\\\"hljs-title\\\"\u003Eany\u003C\u002Fspan\u003E\u003E(\u003Cspan class=\\\"hljs-params\\\"\u003Ea: A, b: B\u003C\u002Fspan\u003E): \u003Cspan class=\\\"hljs-title\\\"\u003Eboolean\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-title\\\"\u003Edeclare\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title\\\"\u003Enamespace\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title\\\"\u003EisEqual\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{}\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Eexport\u003C\u002Fspan\u003E = isEqual\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAs a single function that compares two elements and returns a boolean, you can imagine the use cases are fairly wide-ranging. Folks want to compare deeply-nested objects and get a proper result, and I can relate! This package is a fork of a package that does the same comparison, but this package adds handlers specific to React (and now Preact\u002Fcompat!), allowing it to dive deeply into React components and pull out the correct value for comparison.\u003C\u002Fp\u003E\\n\u003Ch2\u003ETypeScript Usage Testing Goal\u003C\u002Fh2\u003E\\n\u003Cp\u003EWe want to target a specific directory to test our TypeScript in real-time, but without affecting the entire project ecosystem.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe want this script to successfully run both locally and in CI, in 3 different Node environments.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe want this test to identify any regressions introduced to the src or types themselves.\u003C\u002Fp\u003E\\n\u003Ch2\u003E\u003Ccode\u003Etsc\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\\n\u003Cp\u003ESo, we have a set of tests living inside of a \u003Ccode\u003Etest\u002Ftypescript\u003C\u002Fcode\u003E dir. We are reaching these tests with a script that is run from the root's \u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-js\\\"\u003E\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F The script we are focused on testing right now\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-string\\\"\u003E\\\"test-ts-usage\\\"\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"tsc --jsx react --target ES6 --noImplicitAny --esModuleInterop typescript\u002Findex.tsx\\\"\u003C\u002Fspan\u003E,\\n\\n\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F This script existed before this test addition\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F It runs the existing index and makes sure there are no immediate errs\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-string\\\"\u003E\\\"test-ts-defs\\\"\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"tsc --target ES5 --noImplicitAny index.d.ts\\\"\u003C\u002Fspan\u003E,\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch3\u003EWhat is it doing right now?\u003C\u002Fh3\u003E\\n\u003Cp\u003ECurrently, when we run our \u003Ccode\u003Etest-ts-usage\u003C\u002Fcode\u003E script, it is compiling \u003Cem\u003Eevery\u003C\u002Fem\u003E package we depend on, including testing libraries that aren't being invoked by our test file itself. This is because of the compiler. I am suspicious that it's viewing the project as a single entity, hence the all-encompassing compiling, so let's dive into the compiler to see what options we'll need to flag to get it to treat this single \u003Ccode\u003Etsx\u003C\u002Fcode\u003E file as an independently nested project.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo see the test \u003Ccode\u003Etsx\u003C\u002Fcode\u003E file I am running this usage script against, check out this gist of typescript tests. \u003C\u002Fp\u003E\\n\u003Ch3\u003EHow can we fix this?\u003C\u002Fh3\u003E\\n\u003Cp\u003EWe can use a combination of \u003Ca href=\\\"https:\u002F\u002Fwww.typescriptlang.org\u002Fdocs\u002Fhandbook\u002Fcompiler-options.html\\\"\u003Ecompiler options\u003C\u002Fa\u003E and a \u003Ca href=\\\"https:\u002F\u002Fwww.typescriptlang.org\u002Fdocs\u002Fhandbook\u002Fproject-references.html\\\"\u003Eproject reference\u003C\u002Fa\u003E to achieve our testing goal here.\u003C\u002Fp\u003E\\n\u003Cp\u003EUsing the project reference, we can direct \u003Ccode\u003Etsc\u003C\u002Fcode\u003E to view our mini suite as a project of its own, without installing peer dependencies from the root repository. But what is required to substantiate an entire project? How much boilerplate needs to be initialized?\u003C\u002Fp\u003E\\n\u003Cp\u003EAccording to \u003Ca href=\\\"https:\u002F\u002Fwww.typescriptlang.org\u002Fdocs\u002Fhandbook\u002Fproject-references.html#what-is-a-project-reference\\\"\u003Ethis blurb\u003C\u002Fa\u003E in the docs defining a project reference, we only need to\u003C\u002Fp\u003E\\n\u003Col\u003E\\n\u003Cli\u003E\\n\u003Cp\u003EAdd a top-level key of \u003Ccode\u003Ereferences\u003C\u002Fcode\u003E to our root \u003Ccode\u003Etsconfig.json\u003C\u002Fcode\u003E, a small array of objects of projects to refer to.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-js\\\"\u003E\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F* react-fast-compare\u002Ftsconfig.json *\u002F\u003C\u002Fspan\u003E\\n{\\n \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"compilerOptions\\\"\u003C\u002Fspan\u003E: {\\n   \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"noImplicitAny\\\"\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-literal\\\"\u003Etrue\u003C\u002Fspan\u003E\\n },\\n \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"references\\\"\u003C\u002Fspan\u003E: [{ \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"path\\\"\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"test\u002Ftypescript\\\"\u003C\u002Fspan\u003E }]\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\\n\u003Cp\u003EAdd a \u003Ccode\u003Etsconfig,json\u003C\u002Fcode\u003E to the test directory we've pointed to as a separate project. All referenced projects need to have the \u003Ca href=\\\"https:\u002F\u002Fwww.typescriptlang.org\u002Fdocs\u002Fhandbook\u002Fproject-references.html#composite\\\"\u003E\u003Ccode\u003Ecomposite\u003C\u002Fcode\u003E flag\u003C\u002Fa\u003E enabled \\\"to ensure TypeScript can quickly determine where to find the outputs of the referenced project\\\". \u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Cp\u003ENow we can isolate our react-specific flags to the following:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"hljs language-js\\\"\u003E\u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F* react-fast-compare\u002Ftest\u002Ftypescript\u002Ftsconfig.json *\u002F\u003C\u002Fspan\u003E\\n{\\n \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"compilerOptions\\\"\u003C\u002Fspan\u003E: {\\n   \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"composite\\\"\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-literal\\\"\u003Etrue\u003C\u002Fspan\u003E,\\n   \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"esModuleInterop\\\"\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-literal\\\"\u003Etrue\u003C\u002Fspan\u003E,\\n   \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"jsx\\\"\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"react\\\"\u003C\u002Fspan\u003E,\\n   \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"target\\\"\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-string\\\"\u003E\\\"ES6\\\"\u003C\u002Fspan\u003E\\n }\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch3\u003EMore about \u003Ccode\u003Etsconfig\u003C\u002Fcode\u003Es\u003C\u002Fh3\u003E\\n\u003Cp\u003ELooking at \u003Ca href=\\\"https:\u002F\u002Fwww.typescriptlang.org\u002Fdocs\u002Fhandbook\u002Ftsconfig-json.html\\\"\u003Ethe docs\u003C\u002Fa\u003E, we know that the presence of a \u003Ccode\u003Etsconfig.json\u003C\u002Fcode\u003E in a directory indicates that the directory is the \u003Cem\u003Eroot\u003C\u002Fem\u003E of a TypeScript project.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe file is used to specify\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003Eroot files and their names\u003C\u002Fli\u003E\\n\u003Cli\u003Ecompiler options required to compile the project\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ccode\u003Etsc\u003C\u002Fcode\u003E is invoked with no input files, the compiler looks for a \u003Ccode\u003Etsconfig\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Etsx\u003C\u002Fcode\u003E is invoked with no input files but a \u003Ccode\u003E--project\u003C\u002Fcode\u003E is passed, specifying the path of a directory containing a tsconfig \u003Cem\u003Eor\u003C\u002Fem\u003E valid json file with configurations (so it \u003Cstrong\u003Ecan\u003C\u002Fstrong\u003E be renamed in a sub-directory!)\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cblockquote\u003E\\n\u003Cp\u003EWhen input files are specified on the command line, tsconfig.json files are ignored.\u003C\u002Fp\u003E\\n\u003C\u002Fblockquote\u003E\\n\u003Cp\u003ESo, this means, we can designate a project, point to a valid .json within that directory, and compile it independently. We now know we have the option to \u003Cem\u003Eextend\u003C\u002Fem\u003E a root \u003Ccode\u003Etsconfig\u003C\u002Fcode\u003E, or override it completely. I think it'll be more worthwhile to extend our existing config because the project is tiny enough that our source-of-truth approach should suffice; we don't need a wide variety of \u003Ccode\u003Etsconfig\u003C\u002Fcode\u003Es to test against or anything.\u003C\u002Fp\u003E\"}"}</script>
</div>
  </body>
</html>
