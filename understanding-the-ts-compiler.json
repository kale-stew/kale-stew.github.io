{"metadata":{"title":"Understanding the TypeScript Compiler","date":"May 19, 2020","excerpt":"Working to better understand the language and how it differs from my first love, JavaScript."},"content":"<p>I am trying to thoroughly test a library that has TypeScript support, but too many use cases to accurately track without contacting hundreds of thousands of consumers of said library to ensure we thoroughly understand it's many, many use cases.</p>\n<p>The library consists of a single function, and the types themselves are very simple:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">declare</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isEqual</span>&#x3C;<span class=\"hljs-title\">A</span> = <span class=\"hljs-title\">any</span>, <span class=\"hljs-title\">B</span> = <span class=\"hljs-title\">any</span>>(<span class=\"hljs-params\">a: A, b: B</span>): <span class=\"hljs-title\">boolean</span>\n<span class=\"hljs-title\">declare</span> <span class=\"hljs-title\">namespace</span> <span class=\"hljs-title\">isEqual</span> </span>{}\n<span class=\"hljs-keyword\">export</span> = isEqual\n</code></pre>\n<p>As a single function that compares two elements and returns a boolean, you can imagine the use cases are fairly wide-ranging. Folks want to compare deeply-nested objects and get a proper result, and I can relate! This package is a fork of a package that does the same comparison, but this package adds handlers specific to React (and now Preact/compat!), allowing it to dive deeply into React components and pull out the correct value for comparison.</p>\n<h2>TypeScript Usage Testing Goal</h2>\n<p>We want to target a specific directory to test our TypeScript in real-time, but without affecting the entire project ecosystem.</p>\n<p>We want this script to successfully run both locally and in CI, in 3 different Node environments.</p>\n<p>We want this test to identify any regressions introduced to the src or types themselves.</p>\n<h2><code>tsc</code></h2>\n<p>So, we have a set of tests living inside of a <code>test/typescript</code> dir. We are reaching these tests with a script that is run from the root's <code>package.json</code>:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// The script we are focused on testing right now</span>\n<span class=\"hljs-string\">\"test-ts-usage\"</span>: <span class=\"hljs-string\">\"tsc --jsx react --target ES6 --noImplicitAny --esModuleInterop typescript/index.tsx\"</span>,\n\n<span class=\"hljs-comment\">// This script existed before this test addition</span>\n<span class=\"hljs-comment\">// It runs the existing index and makes sure there are no immediate errs</span>\n<span class=\"hljs-string\">\"test-ts-defs\"</span>: <span class=\"hljs-string\">\"tsc --target ES5 --noImplicitAny index.d.ts\"</span>,\n</code></pre>\n<h3>What is it doing right now?</h3>\n<p>Currently, when we run our <code>test-ts-usage</code> script, it is compiling <em>every</em> package we depend on, including testing libraries that aren't being invoked by our test file itself. This is because of the compiler. I am suspicious that it's viewing the project as a single entity, hence the all-encompassing compiling, so let's dive into the compiler to see what options we'll need to flag to get it to treat this single <code>tsx</code> file as an independently nested project.</p>\n<p>To see the test <code>tsx</code> file I am running this usage script against, check out this gist of typescript tests. </p>\n<h3>How can we fix this?</h3>\n<p>We can use a combination of <a href=\"https://www.typescriptlang.org/docs/handbook/compiler-options.html\">compiler options</a> and a <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html\">project reference</a> to achieve our testing goal here.</p>\n<p>Using the project reference, we can direct <code>tsc</code> to view our mini suite as a project of its own, without installing peer dependencies from the root repository. But what is required to substantiate an entire project? How much boilerplate needs to be initialized?</p>\n<p>According to <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html#what-is-a-project-reference\">this blurb</a> in the docs defining a project reference, we only need to</p>\n<ol>\n<li>\n<p>Add a top-level key of <code>references</code> to our root <code>tsconfig.json</code>, a small array of objects of projects to refer to.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* react-fast-compare/tsconfig.json */</span>\n{\n <span class=\"hljs-string\">\"compilerOptions\"</span>: {\n   <span class=\"hljs-string\">\"noImplicitAny\"</span>: <span class=\"hljs-literal\">true</span>\n },\n <span class=\"hljs-string\">\"references\"</span>: [{ <span class=\"hljs-string\">\"path\"</span>: <span class=\"hljs-string\">\"test/typescript\"</span> }]\n}\n</code></pre>\n</li>\n<li>\n<p>Add a <code>tsconfig,json</code> to the test directory we've pointed to as a separate project. All referenced projects need to have the <a href=\"https://www.typescriptlang.org/docs/handbook/project-references.html#composite\"><code>composite</code> flag</a> enabled \"to ensure TypeScript can quickly determine where to find the outputs of the referenced project\". </p>\n</li>\n</ol>\n<p>Now we can isolate our react-specific flags to the following:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* react-fast-compare/test/typescript/tsconfig.json */</span>\n{\n <span class=\"hljs-string\">\"compilerOptions\"</span>: {\n   <span class=\"hljs-string\">\"composite\"</span>: <span class=\"hljs-literal\">true</span>,\n   <span class=\"hljs-string\">\"esModuleInterop\"</span>: <span class=\"hljs-literal\">true</span>,\n   <span class=\"hljs-string\">\"jsx\"</span>: <span class=\"hljs-string\">\"react\"</span>,\n   <span class=\"hljs-string\">\"target\"</span>: <span class=\"hljs-string\">\"ES6\"</span>\n }\n}\n</code></pre>\n<h3>More about <code>tsconfig</code>s</h3>\n<p>Looking at <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">the docs</a>, we know that the presence of a <code>tsconfig.json</code> in a directory indicates that the directory is the <em>root</em> of a TypeScript project.</p>\n<p>The file is used to specify</p>\n<ul>\n<li>root files and their names</li>\n<li>compiler options required to compile the project\n<ul>\n<li><code>tsc</code> is invoked with no input files, the compiler looks for a <code>tsconfig</code></li>\n<li><code>tsx</code> is invoked with no input files but a <code>--project</code> is passed, specifying the path of a directory containing a tsconfig <em>or</em> valid json file with configurations (so it <strong>can</strong> be renamed in a sub-directory!)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>When input files are specified on the command line, tsconfig.json files are ignored.</p>\n</blockquote>\n<p>So, this means, we can designate a project, point to a valid .json within that directory, and compile it independently. We now know we have the option to <em>extend</em> a root <code>tsconfig</code>, or override it completely. I think it'll be more worthwhile to extend our existing config because the project is tiny enough that our source-of-truth approach should suffice; we don't need a wide variety of <code>tsconfig</code>s to test against or anything.</p>"}